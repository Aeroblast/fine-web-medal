var fineMedal;(()=>{"use strict";var e={d:(r,n)=>{for(var o in n)e.o(n,o)&&!e.o(r,o)&&Object.defineProperty(r,o,{enumerable:!0,get:n[o]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{getPreviews:()=>K,init:()=>$});var n="undefined"!=typeof Float32Array?Float32Array:Array;function o(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,r=arguments.length;r--;)e+=arguments[r]*arguments[r];return Math.sqrt(e)});var t=function(e,r,n,o,t){var i,a=1/Math.tan(r/2);return e[0]=a/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=t&&t!==1/0?(i=1/(o-t),e[10]=(t+o)*i,e[14]=2*t*o*i):(e[10]=-1,e[14]=-2*o),e};function i(e,r){var n=r[0],o=r[1],t=r[2],i=r[3],a=r[4],c=r[5],u=r[6],s=r[7],l=r[8],m=r[9],f=r[10],v=r[11],d=r[12],h=r[13],g=r[14],x=r[15],p=n*c-o*a,M=n*u-t*a,y=n*s-i*a,w=o*u-t*c,P=o*s-i*c,_=t*s-i*u,b=l*h-m*d,T=l*g-f*d,E=l*x-v*d,N=m*g-f*h,C=m*x-v*h,R=f*x-v*g,A=p*R-M*C+y*N+w*E-P*T+_*b;return A?(A=1/A,e[0]=(c*R-u*C+s*N)*A,e[1]=(u*E-a*R-s*T)*A,e[2]=(a*C-c*E+s*b)*A,e[3]=(t*C-o*R-i*N)*A,e[4]=(n*R-t*E+i*T)*A,e[5]=(o*E-n*C-i*b)*A,e[6]=(h*_-g*P+x*w)*A,e[7]=(g*y-d*_-x*M)*A,e[8]=(d*P-h*y+x*p)*A,e):null}function a(e,r,n){const o=e.createShader(r);return e.shaderSource(o,n),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(alert("An error occurred compiling the shaders: "+e.getShaderInfoLog(o)),e.deleteShader(o),null)}function c(e,r,n){const o=a(e,e.VERTEX_SHADER,r),t=a(e,e.FRAGMENT_SHADER,n),i=e.createProgram();return e.attachShader(i,o),e.attachShader(i,t),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS)?i:(alert("Unable to initialize the shader program: "+e.getProgramInfoLog(i)),null)}function u(e,r,n,o,t=""){n=n.split(" "),o=o.split(" "),t=t.split(" ");const i={program:r,attribLocations:{},uniformLocations:{},uniformLocations_ext:{}};return n.forEach((n=>i.attribLocations[n]=e.getAttribLocation(r,n))),o.forEach((n=>i.uniformLocations[n]=e.getUniformLocation(r,n))),t.forEach((n=>i.uniformLocations_ext[n]=e.getUniformLocation(r,n))),i}function s(e,r){r.vertexBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,r.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,r.vertex,e.STATIC_DRAW),r.normalBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,r.normalBuffer),e.bufferData(e.ARRAY_BUFFER,r.normal,e.STATIC_DRAW),r.indexBuffer=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r.indices,e.STATIC_DRAW)}function l(e){const r=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return[e[0]/r,e[1]/r,e[2]/r]}function m(e,r,n=0){const o=[];for(let t=0;t<e;t++){const i=2*Math.PI*t/e,a=r*Math.cos(i),c=r*Math.sin(i);o.push([a,c,n])}return o}function f(e,r,n=0){const o=m(e,r,n),t=e+1,i=new Float32Array(3*t),a=new Float32Array(3*t);let c=0,u=[0,0,1];o.forEach((e=>{i.set(e,c),a.set(u,c),c+=3})),i.set([0,0,n],c),a.set(u,c);const s=[],l=t-1;for(let r=0;r<e;r++)s.push(r,(r+1)%e,l);return{vertex:i,normal:a,indices:new Uint16Array(s)}}const v={seg_cirle:64,seg_edge:32,radius:1,edge_count:Math.floor(128/3),radius_inner:.93,radius_edge:1-.93};const d="varying highp vec3 vColor;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvoid main(void) {\n    highp vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    highp float shininess = 32.0;\n          \n    //gl_FragColor = texture2D(uSampler, vTextureCoord)\n    highp vec3 lightDir = normalize(vPosition - vec3(3, 0, 4));\n    highp vec3 viewDir = normalize(vec3(0.0, -0.0, -1));\n    highp vec3 reflectDir = reflect(-lightDir, vTransformedNormal);\n    highp float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    specularColor = specular * specularColor;\n\n    gl_FragColor = vec4(vColor + specularColor, 1.0);\n    //gl_FragColor = vec4(vColor, 1.0); //for debug\n   \n}",h="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp vec3 uBaseColor;\nvarying highp vec3 vColor;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    highp vec3 viewDir = vec3(0, 0, -1);\n    highp float amb = max(-dot(vTransformedNormal, viewDir), 0.0);\n    vColor = uBaseColor * (0.5 + 0.5 * amb);\n}",g="varying highp vec2 vTextureCoord;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n\n    highp vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    highp float shininess = 32.0;\n          \n    highp vec3 lightDir = normalize(vPosition - vec3(3, 0, 4));\n    highp vec3 viewDir = normalize(vec3(0.0, -0.0, -1));\n    highp vec3 reflectDir = reflect(-lightDir, vTransformedNormal);\n    highp float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    specularColor = specular * specularColor;\n    gl_FragColor = baseColor + vec4(specularColor, 1.0);\n\n}\n",x="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec2 vTextureCoord;\nvarying highp vec3 vPosition;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}",p="varying highp vec3 vColor;\nvoid main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n}",M="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp vec3 uBaseColor;\nvarying highp vec3 vColor;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n\n    highp vec3 transformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    highp vec3 viewDir = vec3(0, 0, -1);\n    highp float amb = max(-dot(transformedNormal, viewDir), 0.0);\n    vColor = uBaseColor * (0.5 + 0.5 * amb);\n}",y="varying highp vec2 vTextureCoord;\nvarying highp float amb;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = baseColor * (0.5 + 0.5 * amb);\n}\n",w="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\n\nvarying highp vec2 vTextureCoord;\nvarying highp float amb;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    highp vec3 transformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    \n    highp vec3 viewDir = vec3(0, 0, -1);\n    amb = max(-dot(transformedNormal, viewDir), 0.0);\n    \n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}";function P(e,r){const n=e.getBoundingClientRect();return{x:r.clientX-n.left,y:r.clientY-n.top,w:n.width,h:n.height}}let _=null;function b(e,r,n,o,t){if(_)return;_=e,e.className="hide";const i=e.getBoundingClientRect(),a=window.innerWidth,c=(window.innerHeight,i.left+i.width/2);i.top,i.height,r.className="show_trans";const u=`\n    ${n}.show_trans {\n        opacity: 0;\n        transform: translate(-50%, 0) scale(0);\n        top: 40px;\n        left: ${c}px;\n     }\n  \n    ${n}.show {\n        opacity: 1;\n        transform: translate(-50%, 0) scale(1);\n        top: 10px;\n        left: ${a/2}px;\n    }`;o.innerHTML=u,requestAnimationFrame((()=>{r.className="show",t()}))}const T=[-0,0,-2.7],E=o(),N=.1,C=100,R=2*Math.PI,A=5*Math.PI/180,L=.9,V=1e-4,I=2e-5;let B=0,F=0;function S(e,r){const{x:n,y:o,w:t,h:i}=e;let a=n-t/2,c=o-i/2;if(a*a+c*c>t*t/4*.9)return;let u=a*Math.min(r,800)*.001*.001;F+=u}let D,U,j,Y,q,z,O,H=!1;function G(e,r,t=!0,a=0){H=t;let c=0;B=0,F=0,requestAnimationFrame((function t(u){let s=u-c;switch(s>100&&(s=1e3/30),c=u,a){case 0:break;case 1:B+=9e-4*s;break;case 2:!function(e){B+=e*F,B>R&&(B-=R),B<0&&(B+=R),B<Math.PI?B<A?(F*=L,F+=(Math.random()-.5)*V):F-=I*(B-A)*e:R-B<A?(F*=L,F+=(Math.random()-.5)*V):F+=I*(R-B-A)*e}(s)}const l=o();var m,f,v,d,h,g,x,p,M,y,w,P,_,b,N,C,S,D;m=l,f=l,C=(v=T)[0],S=v[1],D=v[2],f===m?(m[12]=f[0]*C+f[4]*S+f[8]*D+f[12],m[13]=f[1]*C+f[5]*S+f[9]*D+f[13],m[14]=f[2]*C+f[6]*S+f[10]*D+f[14],m[15]=f[3]*C+f[7]*S+f[11]*D+f[15]):(d=f[0],h=f[1],g=f[2],x=f[3],p=f[4],M=f[5],y=f[6],w=f[7],P=f[8],_=f[9],b=f[10],N=f[11],m[0]=d,m[1]=h,m[2]=g,m[3]=x,m[4]=p,m[5]=M,m[6]=y,m[7]=w,m[8]=P,m[9]=_,m[10]=b,m[11]=N,m[12]=d*C+p*S+P*D+f[12],m[13]=h*C+M*S+_*D+f[13],m[14]=g*C+y*S+b*D+f[14],m[15]=x*C+w*S+N*D+f[15]),function(e,r,n){var o=Math.sin(n),t=Math.cos(n),i=r[0],a=r[1],c=r[2],u=r[3],s=r[8],l=r[9],m=r[10],f=r[11];r!==e&&(e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15]),e[0]=i*t-s*o,e[1]=a*t-l*o,e[2]=c*t-m*o,e[3]=u*t-f*o,e[8]=i*o+s*t,e[9]=a*o+l*t,e[10]=c*o+m*t,e[11]=u*o+f*t}(l,l,B),r.view=l,function(e,r,o,t){e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);for(const t of o)for(const o of t.parts){e.useProgram(o.programInfo.program),e.bindBuffer(e.ARRAY_BUFFER,o.geomertry.vertexBuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,o.geomertry.indexBuffer),e.enableVertexAttribArray(o.programInfo.attribLocations.aVertexPosition),e.vertexAttribPointer(o.programInfo.attribLocations.aVertexPosition,3,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,o.geomertry.normalBuffer),e.enableVertexAttribArray(o.programInfo.attribLocations.aVertexNormal),e.vertexAttribPointer(o.programInfo.attribLocations.aVertexNormal,3,e.FLOAT,!1,0,0),e.uniformMatrix4fv(o.programInfo.uniformLocations.uProjectionMatrix,!1,r),e.uniformMatrix4fv(o.programInfo.uniformLocations.uModelViewMatrix,!1,t.view);const c=(a=void 0,a=new n(9),n!=Float32Array&&(a[1]=0,a[2]=0,a[3]=0,a[5]=0,a[6]=0,a[7]=0),a[0]=1,a[4]=1,a[8]=1,a);i(c,t.view),e.uniformMatrix3fv(o.programInfo.uniformLocations.uNormalMatrix,!1,c);for(const r in o.programInfo.uniformLocations_ext){const n=o.programInfo.uniformLocations_ext[r],t=o[r];e[t.func](n,t.v)}void 0!==o.programInfo.uniformLocations.uSampler&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,o.texture),e.uniform1i(o.programInfo.uniformLocations.uSampler,0));const u=o.geomertry.indices.length,s=0;e.drawElements(e.TRIANGLES,u,e.UNSIGNED_SHORT,s)}var a}(e,E,[r]),H&&requestAnimationFrame(t)}))}const W={},X={};let k;async function $(e){if(O=e,D=document.querySelector(O.dialog_selector),U=document.querySelector(O.canvas_selector),j=document.querySelector(O.style_selector),Y=document.querySelector(O.name_selector),q=document.querySelector(O.desc_selector),z=function(e){const r=e.getContext("webgl2");return r?(r.clearColor(0,0,0,0),r.clearDepth(1),r.enable(r.DEPTH_TEST),r.depthFunc(r.LEQUAL),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,!0),r):(alert("Unable to initialize WebGL. Your browser may not support it."),null)}(U),!z)return;const r=c(z,h,d),n=u(z,r,"aVertexPosition aVertexNormal","uModelViewMatrix uProjectionMatrix uNormalMatrix","uBaseColor"),i=c(z,x,g),a=u(z,i,"aVertexPosition aVertexNormal","uSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),b=c(z,M,p),T=u(z,b,"aVertexPosition aVertexNormal","uModelViewMatrix uProjectionMatrix uNormalMatrix","uBaseColor"),R=c(z,w,y),A=u(z,R,"aVertexPosition aVertexNormal","uSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),L=function(){const{seg_cirle:e,seg_edge:r,radius:n,edge_count:o,radius_inner:t,radius_edge:i}=v,a=[];for(let n=0;n<=o;n++){const o=Math.PI*n/r,c=-i*Math.cos(o),u=i*Math.sin(o);a.push(m(e,t+u,c))}const c=a.length*e+1,u=new Float32Array(3*c),s=new Float32Array(3*c);let f=0;a.forEach((e=>{e.forEach((e=>{u.set(e,f);const r=function(e,r){const n=e[0],o=e[1],t=e[2],i=l([n,o,0]).map((e=>e*r));return l([n-i[0],o-i[1],t-i[2]])}(e,t);s.set(r,f),f+=3}))})),u.set([0,0,-i],f),s.set([0,0,-1],f);const d=[];for(let r=0;r<a.length-1;r++){const n=r*e;for(let r=0;r<e;r++)d.push(n+r,n+(r+1)%e,n+r+e),d.push(n+(r+1)%e,n+(r+1)%e+e,n+r+e)}const h=c-1;for(let r=0;r<e;r++)d.push((r+1)%e,r,h);return{vertex:u,normal:s,indices:new Uint16Array(d)}}(),V=function(){const{seg_cirle:e,seg_edge:r,radius:n,edge_count:o,radius_inner:t,radius_edge:i}=v,a=Math.PI*o/r,c=-i*Math.cos(a);return f(e,t+i*Math.sin(a),c)}(),I=f(64,1,0),B=f(64,.94,1e-4);s(z,L),s(z,V),s(z,I),s(z,B),k=async function(e){let r,t;switch(e.texture&&(r=await async function(e){const r=W[e];if(r)return r;const n=await async function(e){return new Promise(((r,n)=>{let o=new Image;o.onload=()=>r(o),o.onerror=n,o.src=e}))}(O.texturePath+e+O.textureExt),o=z.createTexture();z.bindTexture(z.TEXTURE_2D,o);const t=z.RGB,i=z.RGB,a=z.UNSIGNED_BYTE;return z.texImage2D(z.TEXTURE_2D,0,t,i,a,n),z.generateMipmap(z.TEXTURE_2D),z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL,!0),W[e]=o,o}(e.texture)),e.type){case"basic":t=function(e,r){return{view:o(),parts:[{programInfo:n,geomertry:L,uBaseColor:{func:"uniform3fv",v:r}},{programInfo:a,geomertry:V,texture:e,uInverseRadius:{func:"uniform1f",v:1/V.vertex[0]}}]}}(r,e.baseColor);break;case"min":t=function(e,r){return{view:o(),parts:[{programInfo:T,geomertry:I,uBaseColor:{func:"uniform3fv",v:r}},{programInfo:A,geomertry:B,texture:e,uInverseRadius:{func:"uniform1f",v:1/B.vertex[0]}}]}}(r,e.baseColor)}return t.name=e.name,t.desc=e.desc,t},function(e,r){!function(e,r){let n=0,o=null,t=!1,i=!1;function a(){const e=performance.now();i&&(r(o,e-n),i=!1)}e.addEventListener("mousedown",(function(e){t||(n=performance.now(),i=!0)})),e.addEventListener("touchstart",(function(r){t=!0,o=P(e,r.touches[0]),n=performance.now(),i=!0})),e.addEventListener("mouseup",(function(r){t||(o=P(e,r),a())})),e.addEventListener("touchend",(function(e){a(),t=!1})),e.addEventListener("mouseout",(function(e){i=!1})),e.addEventListener("touchcancel",(function(e){i=!1,t=!1})),e.addEventListener("focusout",(function(e){i=!1,t=!1}))}(e,S);const n=45*Math.PI/180,o=r.canvas.clientWidth/r.canvas.clientHeight;t(E,n,o,N,C)}(U,z),D.className="idle",D.querySelector("button").onclick=()=>function(e){e.className="show_trans",_.className="",_=null,H=!1,setTimeout((()=>{e.className="idle"}),500)}(D)}async function K(e,r){D.className="init",await J();const n=document.querySelector(e);n.innerHTML="";for(const e of r){let r=X[e];r||(X[e]=await k(O.medals[e]),r=X[e]);let o=r.preview;o||(G(z,r,!1,0),await J(),r.preview=await Q(U),o=r.preview);const t=document.createElement("div");t.setAttribute("data-id",e),t.title=r.name;let i=new Image;i.src=o,t.appendChild(i),t.addEventListener("click",(()=>{b(t,D,O.dialog_selector,j,(()=>{G(z,r,!0,2),Y.innerHTML=r.name,q.innerHTML=r.desc}))})),n.appendChild(t)}D.className="idle"}async function Q(e){return new Promise(((r,n)=>{e.toBlob((e=>{if(e){const n=URL.createObjectURL(e);r(n)}else n(new Error("Canvas toBlob failed."))}))}))}async function J(){return new Promise((e=>{requestAnimationFrame(e)}))}fineMedal=r})();