var fineMedal;(()=>{"use strict";var e={d:(r,n)=>{for(var t in n)e.o(n,t)&&!e.o(r,t)&&Object.defineProperty(r,t,{enumerable:!0,get:n[t]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{getPreviews:()=>ae,init:()=>ie,setShowMode:()=>fe});var n="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,r=arguments.length;r--;)e+=arguments[r]*arguments[r];return Math.sqrt(e)});var o=function(e,r,n,t,o){var i,a=1/Math.tan(r/2);return e[0]=a/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(i=1/(t-o),e[10]=(o+t)*i,e[14]=2*o*t*i):(e[10]=-1,e[14]=-2*t),e};function i(e,r){var n=r[0],t=r[1],o=r[2],i=r[3],a=r[4],u=r[5],c=r[6],l=r[7],s=r[8],m=r[9],f=r[10],v=r[11],d=r[12],h=r[13],g=r[14],x=r[15],p=n*u-t*a,M=n*c-o*a,_=n*l-i*a,T=t*c-o*u,E=t*l-i*u,P=o*l-i*c,y=s*h-m*d,w=s*g-f*d,b=s*x-v*d,R=m*g-f*h,C=m*x-v*h,N=f*x-v*g,I=p*N-M*C+_*R+T*b-E*w+P*y;return I?(I=1/I,e[0]=(u*N-c*C+l*R)*I,e[1]=(c*b-a*N-l*w)*I,e[2]=(a*C-u*b+l*y)*I,e[3]=(o*C-t*N-i*R)*I,e[4]=(n*N-o*b+i*w)*I,e[5]=(t*b-n*C-i*y)*I,e[6]=(h*P-g*E+x*T)*I,e[7]=(g*_-d*P-x*M)*I,e[8]=(d*E-h*_+x*p)*I,e):null}function a(e,r,n){const t=e.createShader(r);return e.shaderSource(t,n),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)?t:(alert("An error occurred compiling the shaders: "+e.getShaderInfoLog(t)),e.deleteShader(t),null)}function u(e,r,n){const t=a(e,e.VERTEX_SHADER,r),o=a(e,e.FRAGMENT_SHADER,n),i=e.createProgram();return e.attachShader(i,t),e.attachShader(i,o),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS)?i:(alert("Unable to initialize the shader program: "+e.getProgramInfoLog(i)),null)}function c(e,r,n,t,o=""){n=n.split(" "),t=t.split(" "),o=o.split(" ");const i={program:r,attribLocations:{},uniformLocations:{},uniformLocations_ext:{}};return n.forEach((n=>i.attribLocations[n]=e.getAttribLocation(r,n))),t.forEach((n=>i.uniformLocations[n]=e.getUniformLocation(r,n))),o.forEach((n=>i.uniformLocations_ext[n]=e.getUniformLocation(r,n))),i}function l(e,r){r.vertexBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,r.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,r.vertex,e.STATIC_DRAW),r.normalBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,r.normalBuffer),e.bufferData(e.ARRAY_BUFFER,r.normal,e.STATIC_DRAW),r.indexBuffer=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r.indices,e.STATIC_DRAW)}function s(e){const r=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return[e[0]/r,e[1]/r,e[2]/r]}function m(e,r,n=0){const t=[];for(let o=0;o<e;o++){const i=2*Math.PI*o/e,a=r*Math.cos(i),u=r*Math.sin(i);t.push([a,u,n])}return t}function f(e,r,n=0){const t=m(e,r,n),o=e+1,i=new Float32Array(3*o),a=new Float32Array(3*o);let u=0,c=[0,0,1];t.forEach((e=>{i.set(e,u),a.set(c,u),u+=3})),i.set([0,0,n],u),a.set(c,u);const l=[],s=o-1;for(let r=0;r<e;r++)l.push(r,(r+1)%e,s);return{vertex:i,normal:a,indices:new Uint16Array(l)}}const v={seg_cirle:64,seg_edge:32,radius:1,edge_count:Math.floor(128/3),radius_inner:.93,radius_edge:1-.93};const d="varying highp vec3 vColor;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvoid main(void) {\n    highp vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    highp float shininess = 32.0;\n          \n    //gl_FragColor = texture2D(uSampler, vTextureCoord)\n    highp vec3 lightDir = normalize(vPosition - vec3(3, 0, 4));\n    highp vec3 viewDir = normalize(vec3(0.0, -0.0, -1));\n    highp vec3 reflectDir = reflect(-lightDir, vTransformedNormal);\n    highp float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    specularColor = specular * specularColor;\n\n    gl_FragColor = vec4(vColor + specularColor, 1.0);\n    //gl_FragColor = vec4(vColor, 1.0); //for debug\n   \n}",h="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp vec3 uBaseColor;\nvarying highp vec3 vColor;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    highp vec3 viewDir = vec3(0, 0, -1);\n    highp float amb = max(-dot(vTransformedNormal, viewDir), 0.0);\n    vColor = uBaseColor * (0.5 + 0.5 * amb);\n}",g="varying highp vec2 vTextureCoord;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n\n    highp vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    highp float shininess = 32.0;\n          \n    highp vec3 lightDir = normalize(vPosition - vec3(3, 0, 4));\n    highp vec3 viewDir = normalize(vec3(0.0, -0.0, -1));\n    highp vec3 reflectDir = reflect(-lightDir, vTransformedNormal);\n    highp float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    specularColor = specular * specularColor;\n    gl_FragColor = baseColor + vec4(specularColor, 1.0);\n\n}\n",x="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec2 vTextureCoord;\nvarying highp vec3 vPosition;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}",p="varying highp vec3 vColor;\nvoid main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n}",M="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp vec3 uBaseColor;\nvarying highp vec3 vColor;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n\n    highp vec3 transformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    highp vec3 viewDir = vec3(0, 0, -1);\n    highp float amb = max(-dot(transformedNormal, viewDir), 0.0);\n    vColor = uBaseColor * (0.5 + 0.5 * amb);\n}",_="varying highp vec2 vTextureCoord;\nvarying highp float amb;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(baseColor.xyz * (0.5 + 0.5 * amb), 1.0);\n}\n",T="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\n\nvarying highp vec2 vTextureCoord;\nvarying highp float amb;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    highp vec3 transformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    \n    highp vec3 viewDir = vec3(0, 0, -1);\n    amb = max(-dot(transformedNormal, viewDir), 0.0);\n    \n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}",E="varying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvarying highp vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform samplerCube uCubeSampler;\n\n \nvoid main() {\n  highp vec3 viewPos = vec3(0,0,0);\n  highp vec3 normal= normalize(vTransformedNormal);\n  highp vec3 eyeToSurfaceDir = normalize(vPosition - viewPos);\n  highp vec3 direction = reflect(eyeToSurfaceDir, normal);\n\n  highp vec4 env = textureCube(uCubeSampler, direction);\n  highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n  gl_FragColor = env*0.6 + baseColor*0.4 ;\n}",P="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvarying highp vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal =uNormalMatrix * aVertexNormal;\n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}";function y(e,r){const n=e.getBoundingClientRect();return{x:r.clientX-n.left,y:r.clientY-n.top,w:n.width,h:n.height}}let w=null;function b(e,r,n,t,o,i){if(w)return;w=e,e.className="fine-medal_hide";const a=e.getBoundingClientRect(),u=window.innerWidth,c=(window.innerHeight,a.left+a.width/2),l=a.top+a.height/2;r.className="fine-medal_show_trans";const s=`\n    ${n}.fine-medal_show_trans {\n        opacity: 0;\n        transform: translate(-50%, 0) scale(0.1);\n        top: ${l-t.height/2}px;\n        left: ${c}px;\n     }\n  \n    ${n}.fine-medal_show {\n        opacity: 1;\n        transform: translate(-50%, 0) scale(1);\n        left: ${u/2}px;\n    }`;o.innerHTML=s,requestAnimationFrame((()=>{r.className="fine-medal_show",i()}))}const R=[-0,0,-2.7],C=t(),N=.1,I=100,A=2*Math.PI;let V=0,B=0;let S=0;const U=[null,function(e){z||(V+=9e-4*e)},function(e){V+=e*B,V>A&&(V-=A),V<0&&(V+=A),V<Math.PI?V<G?(B*=Y,B+=(Math.random()-.5)*O):B-=q*(V-G)*e:A-V<G?(B*=Y,B+=(Math.random()-.5)*O):B+=q*(A-V-G)*e}],L=[null,function(e,r){z=!z},function(e,r){const{x:n,y:t,w:o,h:i}=e;r<300&&(r=40);let a=(n-o/2)*Math.min(r,800)*.001*.001;B+=a}];let D=!1;function F(e,r,o=!0,a=0){D=o,S=a;let u=0;V=0,B=0,requestAnimationFrame((function o(a){let c=a-u;c>100&&(c=1e3/30),u=a;const l=U[S];l&&l(c);const s=t();var m,f,v,d,h,g,x,p,M,_,T,E,P,y,w,b,N,I;m=s,f=s,b=(v=R)[0],N=v[1],I=v[2],f===m?(m[12]=f[0]*b+f[4]*N+f[8]*I+f[12],m[13]=f[1]*b+f[5]*N+f[9]*I+f[13],m[14]=f[2]*b+f[6]*N+f[10]*I+f[14],m[15]=f[3]*b+f[7]*N+f[11]*I+f[15]):(d=f[0],h=f[1],g=f[2],x=f[3],p=f[4],M=f[5],_=f[6],T=f[7],E=f[8],P=f[9],y=f[10],w=f[11],m[0]=d,m[1]=h,m[2]=g,m[3]=x,m[4]=p,m[5]=M,m[6]=_,m[7]=T,m[8]=E,m[9]=P,m[10]=y,m[11]=w,m[12]=d*b+p*N+E*I+f[12],m[13]=h*b+M*N+P*I+f[13],m[14]=g*b+_*N+y*I+f[14],m[15]=x*b+T*N+w*I+f[15]),function(e,r,n){var t=Math.sin(n),o=Math.cos(n),i=r[0],a=r[1],u=r[2],c=r[3],l=r[8],s=r[9],m=r[10],f=r[11];r!==e&&(e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15]),e[0]=i*o-l*t,e[1]=a*o-s*t,e[2]=u*o-m*t,e[3]=c*o-f*t,e[8]=i*t+l*o,e[9]=a*t+s*o,e[10]=u*t+m*o,e[11]=c*t+f*o}(s,s,V),r.view=s,function(e,r,t,o){e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);for(const o of t)for(const t of o.parts){e.useProgram(t.programInfo.program),e.bindBuffer(e.ARRAY_BUFFER,t.geomertry.vertexBuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.geomertry.indexBuffer),e.enableVertexAttribArray(t.programInfo.attribLocations.aVertexPosition),e.vertexAttribPointer(t.programInfo.attribLocations.aVertexPosition,3,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,t.geomertry.normalBuffer),e.enableVertexAttribArray(t.programInfo.attribLocations.aVertexNormal),e.vertexAttribPointer(t.programInfo.attribLocations.aVertexNormal,3,e.FLOAT,!1,0,0),e.uniformMatrix4fv(t.programInfo.uniformLocations.uProjectionMatrix,!1,r),e.uniformMatrix4fv(t.programInfo.uniformLocations.uModelViewMatrix,!1,o.view);const u=(a=void 0,a=new n(9),n!=Float32Array&&(a[1]=0,a[2]=0,a[3]=0,a[5]=0,a[6]=0,a[7]=0),a[0]=1,a[4]=1,a[8]=1,a);i(u,o.view),e.uniformMatrix3fv(t.programInfo.uniformLocations.uNormalMatrix,!1,u);for(const r in t.programInfo.uniformLocations_ext){const n=t.programInfo.uniformLocations_ext[r],o=t[r];e[o.func](n,o.v)}void 0!==t.programInfo.uniformLocations.uSampler&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t.texture),e.uniform1i(t.programInfo.uniformLocations.uSampler,0)),void 0!==t.programInfo.uniformLocations.uCubeSampler&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_CUBE_MAP,t.cubeTexture),e.uniform1i(t.programInfo.uniformLocations.uCubeSampler,1));const c=t.geomertry.indices.length,l=0;e.drawElements(e.TRIANGLES,c,e.UNSIGNED_SHORT,l)}var a}(e,C,[r]),D&&requestAnimationFrame(o)}))}function X(e,r){const n=L[S],{x:t,y:o,w:i,h:a}=e;t<.1*i&&o<.1*a&&r>500&&(S=S%2+1);let u=t-i/2,c=o-a/2;u*u+c*c>i*i/4*.9||n&&n(e,r)}function j(e){return[0,1,2].includes(e)?(S=e,S):(console.warn("Invaild mode: "+e),!1)}let z=!1;const G=5*Math.PI/180,Y=.9,O=1e-4,q=15e-6;let H,W,k,$,K,Z,Q,J;const ee={},re={},ne={};let te,oe;async function ie(e){if(J=e,H=document.querySelector(J.dialog_selector),W=document.querySelector(J.canvas_selector),k=document.querySelector(J.style_selector),$=document.querySelector(J.name_selector),K=document.querySelector(J.desc_selector),Q=function(e){const r=e.getContext("webgl2");return r?(r.clearColor(0,0,0,0),r.clearDepth(1),r.enable(r.DEPTH_TEST),r.depthFunc(r.LEQUAL),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,!0),r):(alert("Unable to initialize WebGL. Your browser may not support it."),null)}(W),!Q)return;const r=u(Q,h,d),n=c(Q,r,"aVertexPosition aVertexNormal","uModelViewMatrix uProjectionMatrix uNormalMatrix","uBaseColor"),i=u(Q,x,g),a=c(Q,i,"aVertexPosition aVertexNormal","uSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),b=u(Q,M,p),R=c(Q,b,"aVertexPosition aVertexNormal","uModelViewMatrix uProjectionMatrix uNormalMatrix","uBaseColor"),A=u(Q,T,_),V=c(Q,A,"aVertexPosition aVertexNormal","uSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),B=u(Q,P,E),S=c(Q,B,"aVertexPosition aVertexNormal","uSampler uCubeSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),U=function(){const{seg_cirle:e,seg_edge:r,radius:n,edge_count:t,radius_inner:o,radius_edge:i}=v,a=[];for(let n=0;n<=t;n++){const t=Math.PI*n/r,u=-i*Math.cos(t),c=i*Math.sin(t);a.push(m(e,o+c,u))}const u=a.length*e+1,c=new Float32Array(3*u),l=new Float32Array(3*u);let f=0;a.forEach((e=>{e.forEach((e=>{c.set(e,f);const r=function(e,r){const n=e[0],t=e[1],o=e[2],i=s([n,t,0]).map((e=>e*r));return s([n-i[0],t-i[1],o-i[2]])}(e,o);l.set(r,f),f+=3}))})),c.set([0,0,-i],f),l.set([0,0,-1],f);const d=[];for(let r=0;r<a.length-1;r++){const n=r*e;for(let r=0;r<e;r++)d.push(n+r,n+(r+1)%e,n+r+e),d.push(n+(r+1)%e,n+(r+1)%e+e,n+r+e)}const h=u-1;for(let r=0;r<e;r++)d.push((r+1)%e,r,h);return{vertex:c,normal:l,indices:new Uint16Array(d)}}(),L=function(){const{seg_cirle:e,seg_edge:r,radius:n,edge_count:t,radius_inner:o,radius_edge:i}=v,a=Math.PI*t/r,u=-i*Math.cos(a);return f(e,o+i*Math.sin(a),u)}(),F=f(64,1,0),j=f(64,.94,1e-4);l(Q,U),l(Q,L),l(Q,F),l(Q,j),oe=Q.createTexture(),Q.bindTexture(Q.TEXTURE_2D,oe),te=async function(e){let r,o,i;switch(e.texture&&(r=await async function(e){const r=ee[e];if(r)return r;const n=await ce(J.texturePath+e+J.textureExt),t=Q.createTexture();Q.bindTexture(Q.TEXTURE_2D,t);const o=Q.RGB,i=Q.RGB,a=Q.UNSIGNED_BYTE;return Q.texImage2D(Q.TEXTURE_2D,0,o,i,a,n),Q.generateMipmap(Q.TEXTURE_2D),ee[e]=t,t}(e.texture)),e.cubeTexture&&(o=await async function(e){const r=[{target:Q.TEXTURE_CUBE_MAP_POSITIVE_X,n:"-p-x"},{target:Q.TEXTURE_CUBE_MAP_NEGATIVE_X,n:"-n-x"},{target:Q.TEXTURE_CUBE_MAP_POSITIVE_Y,n:"-p-y"},{target:Q.TEXTURE_CUBE_MAP_NEGATIVE_Y,n:"-n-y"},{target:Q.TEXTURE_CUBE_MAP_POSITIVE_Z,n:"-p-z"},{target:Q.TEXTURE_CUBE_MAP_NEGATIVE_Z,n:"-n-z"}],n=re[e];if(n)return n;const t=await Promise.all(r.map((async r=>{const n=await ce(J.texturePath+e+r.n+J.textureExt);return{target:r.target,img:n}}))),o=Q.createTexture();Q.bindTexture(Q.TEXTURE_CUBE_MAP,o);for(const e of t){const{target:r,img:n}=e,t=0,o=Q.RGB,i=Q.RGB,a=Q.UNSIGNED_BYTE;Q.texImage2D(r,t,o,i,a,n)}return Q.generateMipmap(Q.TEXTURE_CUBE_MAP),Q.texParameteri(Q.TEXTURE_CUBE_MAP,Q.TEXTURE_MIN_FILTER,Q.LINEAR_MIPMAP_LINEAR),re[e]=o,o}(e.cubeTexture)),e.type){case"basic":i=function(e,r){return{view:t(),parts:[{programInfo:n,geomertry:U,uBaseColor:{func:"uniform3fv",v:r}},{programInfo:a,geomertry:L,texture:e,uInverseRadius:{func:"uniform1f",v:1/L.vertex[0]}}]}}(r,e.baseColor);break;case"min":i=function(e,r){return{view:t(),parts:[{programInfo:R,geomertry:F,uBaseColor:{func:"uniform3fv",v:r}},{programInfo:V,geomertry:j,texture:e,uInverseRadius:{func:"uniform1f",v:1/j.vertex[0]}}]}}(r,e.baseColor);break;case"basic_reflect":i=function(e,r,n){return{view:t(),parts:[{programInfo:S,geomertry:U,texture:le(n),cubeTexture:r,uInverseRadius:{func:"uniform1f",v:1}},{programInfo:S,geomertry:L,texture:e,cubeTexture:r,uInverseRadius:{func:"uniform1f",v:1/L.vertex[0]}}]}}(r,o,e.baseColor)}return i.name=e.name,i.desc=e.desc,i},function(e,r){!function(e,r){let n=0,t=null,o=!1,i=!1;function a(){const e=performance.now();i&&(r(t,e-n),i=!1)}e.addEventListener("mousedown",(function(e){o||(n=performance.now(),i=!0)})),e.addEventListener("touchstart",(function(r){o=!0,t=y(e,r.touches[0]),n=performance.now(),i=!0})),e.addEventListener("mouseup",(function(r){o||(t=y(e,r),a())})),e.addEventListener("touchend",(function(e){a(),o=!1})),e.addEventListener("mouseout",(function(e){i=!1})),e.addEventListener("touchcancel",(function(e){i=!1,o=!1})),e.addEventListener("focusout",(function(e){i=!1,o=!1}))}(e,X);const n=45*Math.PI/180,t=r.canvas.clientWidth/r.canvas.clientHeight;o(C,n,t,N,I)}(W,Q),H.className="fine-medal_idle",H.querySelector("button").onclick=()=>function(e){e.className="fine-medal_show_trans",w.className="",w=null,D=!1,setTimeout((()=>{e.className="fine-medal_idle"}),500)}(H)}async function ae(e,r){H.className="fine-medal_init",await me(),Z=H.getBoundingClientRect();const n=document.querySelector(e);n.innerHTML="";const t=await Promise.all(r.map((async e=>{let r=ne[e];return r||(ne[e]=await te(J.medals[e]),r=ne[e],r.id=e),r})));for(const e of t){let r=e.preview;r||(F(Q,e,!1,0),await me(),e.preview=await se(W),r=e.preview);const t=document.createElement("div");t.setAttribute("data-id",e.id),t.title=e.name;let o=new Image;o.src=r,t.appendChild(o),t.addEventListener("click",(()=>{b(t,H,J.dialog_selector,Z,k,(()=>{F(Q,e,!0,2),$.innerHTML=e.name,K.innerHTML=e.desc}))})),n.appendChild(t)}H.className="fine-medal_idle"}const ue={};async function ce(e){return ue[e]||new Promise(((r,n)=>{let t=new Image;t.onload=()=>{ue[e]=t,r(t)},t.onerror=n,t.src=e}))}function le(e){Q.bindTexture(Q.TEXTURE_2D,oe);const r=Q.RGB,n=Q.RGB,t=Q.UNSIGNED_BYTE,o=new Uint8Array(e.map((e=>255*e)));return Q.texImage2D(Q.TEXTURE_2D,0,r,1,1,0,n,t,o),oe}async function se(e){return new Promise(((r,n)=>{e.toBlob((e=>{if(e){const n=URL.createObjectURL(e);r(n)}else n(new Error("Canvas toBlob failed."))}))}))}async function me(){return new Promise((e=>{requestAnimationFrame(e)}))}function fe(e){return j(e)}fineMedal=r})();