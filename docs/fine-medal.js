var fineMedal;(()=>{"use strict";var e={d:(r,n)=>{for(var t in n)e.o(n,t)&&!e.o(r,t)&&Object.defineProperty(r,t,{enumerable:!0,get:n[t]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{getPreviews:()=>ce,init:()=>ue,setShowMode:()=>xe});var n="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,r=arguments.length;r--;)e+=arguments[r]*arguments[r];return Math.sqrt(e)});var o=function(e,r,n,t,o){var i,a=1/Math.tan(r/2);return e[0]=a/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(i=1/(t-o),e[10]=(o+t)*i,e[14]=2*o*t*i):(e[10]=-1,e[14]=-2*t),e};function i(e,r){var n=r[0],t=r[1],o=r[2],i=r[3],a=r[4],u=r[5],c=r[6],l=r[7],s=r[8],m=r[9],f=r[10],v=r[11],d=r[12],h=r[13],g=r[14],x=r[15],p=n*u-t*a,T=n*c-o*a,M=n*l-i*a,_=t*c-o*u,E=t*l-i*u,y=o*l-i*c,P=s*h-m*d,b=s*g-f*d,w=s*x-v*d,C=m*g-f*h,R=m*x-v*h,I=f*x-v*g,N=p*I-T*R+M*C+_*w-E*b+y*P;return N?(N=1/N,e[0]=(u*I-c*R+l*C)*N,e[1]=(c*w-a*I-l*b)*N,e[2]=(a*R-u*w+l*P)*N,e[3]=(o*R-t*I-i*C)*N,e[4]=(n*I-o*w+i*b)*N,e[5]=(t*w-n*R-i*P)*N,e[6]=(h*y-g*E+x*_)*N,e[7]=(g*M-d*y-x*T)*N,e[8]=(d*E-h*M+x*p)*N,e):null}function a(e,r,n){const t=e.createShader(r);return e.shaderSource(t,n),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)?t:(alert("An error occurred compiling the shaders: "+e.getShaderInfoLog(t)),e.deleteShader(t),null)}function u(e,r,n){const t=a(e,e.VERTEX_SHADER,r),o=a(e,e.FRAGMENT_SHADER,n),i=e.createProgram();return e.attachShader(i,t),e.attachShader(i,o),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS)?i:(alert("Unable to initialize the shader program: "+e.getProgramInfoLog(i)),null)}function c(e,r,n,t,o=""){n=n.split(" "),t=t.split(" "),o=o.split(" ");const i={program:r,attribLocations:{},uniformLocations:{},uniformLocations_ext:{}};return n.forEach((n=>i.attribLocations[n]=e.getAttribLocation(r,n))),t.forEach((n=>i.uniformLocations[n]=e.getUniformLocation(r,n))),o.forEach((n=>i.uniformLocations_ext[n]=e.getUniformLocation(r,n))),i}function l(e,r){r.vertexBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,r.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,r.vertex,e.STATIC_DRAW),r.normalBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,r.normalBuffer),e.bufferData(e.ARRAY_BUFFER,r.normal,e.STATIC_DRAW),r.indexBuffer=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r.indices,e.STATIC_DRAW)}function s(e){const r=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return[e[0]/r,e[1]/r,e[2]/r]}function m(e,r,n=0){const t=[];for(let o=0;o<e;o++){const i=2*Math.PI*o/e,a=r*Math.cos(i),u=r*Math.sin(i);t.push([a,u,n])}return t}function f(e,r,n=0){const t=m(e,r,n),o=e+1,i=new Float32Array(3*o),a=new Float32Array(3*o);let u=0,c=[0,0,1];t.forEach((e=>{i.set(e,u),a.set(c,u),u+=3})),i.set([0,0,n],u),a.set(c,u);const l=[],s=o-1;for(let r=0;r<e;r++)l.push(r,(r+1)%e,s);return{vertex:i,normal:a,indices:new Uint16Array(l)}}const v={seg_cirle:64,seg_edge:32,radius:1,edge_count:Math.floor(128/3),radius_inner:.93,radius_edge:1-.93};const d="varying highp vec3 vColor;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvoid main(void) {\n    highp vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    highp float shininess = 32.0;\n          \n    //gl_FragColor = texture2D(uSampler, vTextureCoord)\n    highp vec3 lightDir = normalize(vPosition - vec3(3, 0, 4));\n    highp vec3 viewDir = normalize(vec3(0.0, -0.0, -1));\n    highp vec3 reflectDir = reflect(-lightDir, vTransformedNormal);\n    highp float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    specularColor = specular * specularColor;\n\n    gl_FragColor = vec4(vColor + specularColor, 1.0);\n    //gl_FragColor = vec4(vColor, 1.0); //for debug\n   \n}",h="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp vec3 uBaseColor;\nvarying highp vec3 vColor;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    highp vec3 viewDir = vec3(0, 0, -1);\n    highp float amb = max(-dot(vTransformedNormal, viewDir), 0.0);\n    vColor = uBaseColor * (0.5 + 0.5 * amb);\n}",g="varying highp vec2 vTextureCoord;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n\n    highp vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    highp float shininess = 32.0;\n          \n    highp vec3 lightDir = normalize(vPosition - vec3(3, 0, 4));\n    highp vec3 viewDir = normalize(vec3(0.0, -0.0, -1));\n    highp vec3 reflectDir = reflect(-lightDir, vTransformedNormal);\n    highp float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    specularColor = specular * specularColor;\n    gl_FragColor = baseColor + vec4(specularColor, 1.0);\n\n}\n",x="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec2 vTextureCoord;\nvarying highp vec3 vPosition;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}",p="varying highp vec3 vColor;\nvoid main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n}",T="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp vec3 uBaseColor;\nvarying highp vec3 vColor;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n\n    highp vec3 transformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    highp vec3 viewDir = vec3(0, 0, -1);\n    highp float amb = max(-dot(transformedNormal, viewDir), 0.0);\n    vColor = uBaseColor * (0.5 + 0.5 * amb);\n}",M="varying highp vec2 vTextureCoord;\nvarying highp float amb;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(baseColor.xyz * (0.5 + 0.5 * amb), 1.0);\n}\n",_="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\n\nvarying highp vec2 vTextureCoord;\nvarying highp float amb;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    highp vec3 transformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    \n    highp vec3 viewDir = vec3(0, 0, -1);\n    amb = max(-dot(transformedNormal, viewDir), 0.0);\n    \n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}",E="varying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvarying highp vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform samplerCube uCubeSampler;\n\n \nvoid main() {\n  highp vec3 viewPos = vec3(0,0,0);\n  highp vec3 normal= normalize(vTransformedNormal);\n  highp vec3 eyeToSurfaceDir = normalize(vPosition - viewPos);\n  highp vec3 direction = reflect(eyeToSurfaceDir, normal);\n\n  highp vec4 env = textureCube(uCubeSampler, -direction);\n  highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n  gl_FragColor = env * 0.4 + baseColor * 0.6 ;\n}",y="attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvarying highp vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal =uNormalMatrix * aVertexNormal;\n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}",P="varying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvarying highp vec2 vTextureCoord;\n\n\nuniform highp mat3 uNormalMatrix;\nuniform sampler2D uSampler;\nuniform sampler2D uSampler2;\nuniform samplerCube uCubeSampler;\n\n// 法线，只给平面用的版本\n \nvoid main() {\n  highp vec3 viewPos = vec3(0,0,0);\n  // highp vec3 normal= normalize(vTransformedNormal);\n  highp vec3 subnormal = texture2D(uSampler2, vTextureCoord).xyz * 2.0 - 1.0;\n  highp vec3 normal = uNormalMatrix * subnormal;\n  highp vec3 eyeToSurfaceDir = normalize(vPosition - viewPos);\n\n  highp vec3 direction = reflect(eyeToSurfaceDir, normal);\n\n  highp vec4 env = textureCube(uCubeSampler, -direction);\n  highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n\n  gl_FragColor = env * 0.4 + baseColor * 0.6 ;\n}";function b(e,r){const n=e.getBoundingClientRect();return{x:r.clientX-n.left,y:r.clientY-n.top,w:n.width,h:n.height}}let w=null;function C(e,r,n,t,o,i){if(w)return;w=e,e.className="fine-medal_hide";const a=e.getBoundingClientRect(),u=window.innerWidth,c=(window.innerHeight,a.left+a.width/2),l=a.top+a.height/2;r.className="fine-medal_show_trans";const s=`\n    ${n}.fine-medal_show_trans {\n        opacity: 0;\n        transform: translate(-50%, 0) scale(0.1);\n        top: ${l-t.height/2}px;\n        left: ${c}px;\n     }\n  \n    ${n}.fine-medal_show {\n        opacity: 1;\n        transform: translate(-50%, 0) scale(1);\n        left: ${u/2}px;\n    }`;o.innerHTML=s,requestAnimationFrame((()=>{r.className="fine-medal_show",i()}))}const R=[-0,0,-2.7],I=t(),N=.1,A=100,V=2*Math.PI;let S=0,B=0;let U=0;const D=[null,function(e){G||(S+=9e-4*e)},function(e){S+=e*B,S>V&&(S-=V),S<0&&(S+=V),S<Math.PI?S<Y?(B*=O,B+=(Math.random()-.5)*H):(Math.abs(B)>10&&(B*=q),B-=W*(S-Y)*e):V-S<Y?(B*=O,B+=(Math.random()-.5)*H):B+=W*(V-S-Y)*e}],L=[null,function(e,r){G=!G},function(e,r){const{x:n,y:t,w:o,h:i}=e;r<300&&(r=40);let a=(n-o/2)*Math.min(r,800)*.001*.001;B+=a}];let F=!1;function X(e,r,o=!0,a=0){F=o,U=a;let u=0;S=0,B=0,requestAnimationFrame((function o(a){let c=a-u;c>100&&(c=1e3/30),u=a;const l=D[U];l&&l(c);const s=t();var m,f,v,d,h,g,x,p,T,M,_,E,y,P,b,w,C,N;m=s,f=s,w=(v=R)[0],C=v[1],N=v[2],f===m?(m[12]=f[0]*w+f[4]*C+f[8]*N+f[12],m[13]=f[1]*w+f[5]*C+f[9]*N+f[13],m[14]=f[2]*w+f[6]*C+f[10]*N+f[14],m[15]=f[3]*w+f[7]*C+f[11]*N+f[15]):(d=f[0],h=f[1],g=f[2],x=f[3],p=f[4],T=f[5],M=f[6],_=f[7],E=f[8],y=f[9],P=f[10],b=f[11],m[0]=d,m[1]=h,m[2]=g,m[3]=x,m[4]=p,m[5]=T,m[6]=M,m[7]=_,m[8]=E,m[9]=y,m[10]=P,m[11]=b,m[12]=d*w+p*C+E*N+f[12],m[13]=h*w+T*C+y*N+f[13],m[14]=g*w+M*C+P*N+f[14],m[15]=x*w+_*C+b*N+f[15]),function(e,r,n){var t=Math.sin(n),o=Math.cos(n),i=r[0],a=r[1],u=r[2],c=r[3],l=r[8],s=r[9],m=r[10],f=r[11];r!==e&&(e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15]),e[0]=i*o-l*t,e[1]=a*o-s*t,e[2]=u*o-m*t,e[3]=c*o-f*t,e[8]=i*t+l*o,e[9]=a*t+s*o,e[10]=u*t+m*o,e[11]=c*t+f*o}(s,s,S),r.view=s,function(e,r,t,o){e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);for(const o of t)for(const t of o.parts){e.useProgram(t.programInfo.program),e.bindBuffer(e.ARRAY_BUFFER,t.geomertry.vertexBuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.geomertry.indexBuffer),e.enableVertexAttribArray(t.programInfo.attribLocations.aVertexPosition),e.vertexAttribPointer(t.programInfo.attribLocations.aVertexPosition,3,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,t.geomertry.normalBuffer),e.enableVertexAttribArray(t.programInfo.attribLocations.aVertexNormal),e.vertexAttribPointer(t.programInfo.attribLocations.aVertexNormal,3,e.FLOAT,!1,0,0),e.uniformMatrix4fv(t.programInfo.uniformLocations.uProjectionMatrix,!1,r),e.uniformMatrix4fv(t.programInfo.uniformLocations.uModelViewMatrix,!1,o.view);const u=(a=void 0,a=new n(9),n!=Float32Array&&(a[1]=0,a[2]=0,a[3]=0,a[5]=0,a[6]=0,a[7]=0),a[0]=1,a[4]=1,a[8]=1,a);i(u,o.view),e.uniformMatrix3fv(t.programInfo.uniformLocations.uNormalMatrix,!1,u);for(const r in t.programInfo.uniformLocations_ext){const n=t.programInfo.uniformLocations_ext[r],o=t[r];e[o.func](n,o.v)}void 0!==t.programInfo.uniformLocations.uSampler&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t.texture),e.uniform1i(t.programInfo.uniformLocations.uSampler,0)),void 0!==t.programInfo.uniformLocations.uSampler2&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t.texture2),e.uniform1i(t.programInfo.uniformLocations.uSampler2,1)),void 0!==t.programInfo.uniformLocations.uCubeSampler&&(e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_CUBE_MAP,t.cubeTexture),e.uniform1i(t.programInfo.uniformLocations.uCubeSampler,2));const c=t.geomertry.indices.length,l=0;e.drawElements(e.TRIANGLES,c,e.UNSIGNED_SHORT,l)}var a}(e,I,[r]),F&&requestAnimationFrame(o)}))}function j(e,r){const n=L[U],{x:t,y:o,w:i,h:a}=e;t<.1*i&&o<.1*a&&r>500&&(U=U%2+1);let u=t-i/2,c=o-a/2;u*u+c*c>i*i/4*.9||n&&n(e,r)}function z(e){return[0,1,2].includes(e)?(U=e,U):(console.warn("Invaild mode: "+e),!1)}let G=!1;const Y=5*Math.PI/180,O=.9,q=.8,H=1e-4,W=15e-6;let $,k,K,Z,Q,J,ee,re;const ne={},te={},oe={};let ie,ae;async function ue(e){if(re=e,$=document.querySelector(re.dialog_selector),k=document.querySelector(re.canvas_selector),K=document.querySelector(re.style_selector),Z=document.querySelector(re.name_selector),Q=document.querySelector(re.desc_selector),ee=function(e){const r=e.getContext("webgl2");return r?(r.clearColor(0,0,0,0),r.clearDepth(1),r.enable(r.DEPTH_TEST),r.depthFunc(r.LEQUAL),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,!0),r):(alert("Unable to initialize WebGL. Your browser may not support it."),null)}(k),!ee)return;const r=u(ee,h,d),n=c(ee,r,"aVertexPosition aVertexNormal","uModelViewMatrix uProjectionMatrix uNormalMatrix","uBaseColor"),i=u(ee,x,g),a=c(ee,i,"aVertexPosition aVertexNormal","uSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),C=u(ee,T,p),R=c(ee,C,"aVertexPosition aVertexNormal","uModelViewMatrix uProjectionMatrix uNormalMatrix","uBaseColor"),V=u(ee,_,M),S=c(ee,V,"aVertexPosition aVertexNormal","uSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),B=u(ee,y,E),U=c(ee,B,"aVertexPosition aVertexNormal","uSampler uCubeSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),D=u(ee,y,P),L=c(ee,D,"aVertexPosition aVertexNormal","uSampler uSampler2 uCubeSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),X=function(){const{seg_cirle:e,seg_edge:r,radius:n,edge_count:t,radius_inner:o,radius_edge:i}=v,a=[];for(let n=0;n<=t;n++){const t=Math.PI*n/r,u=-i*Math.cos(t),c=i*Math.sin(t);a.push(m(e,o+c,u))}const u=a.length*e+1,c=new Float32Array(3*u),l=new Float32Array(3*u);let f=0;a.forEach((e=>{e.forEach((e=>{c.set(e,f);const r=function(e,r){const n=e[0],t=e[1],o=e[2],i=s([n,t,0]).map((e=>e*r));return s([n-i[0],t-i[1],o-i[2]])}(e,o);l.set(r,f),f+=3}))})),c.set([0,0,-i],f),l.set([0,0,-1],f);const d=[];for(let r=0;r<a.length-1;r++){const n=r*e;for(let r=0;r<e;r++)d.push(n+r,n+(r+1)%e,n+r+e),d.push(n+(r+1)%e,n+(r+1)%e+e,n+r+e)}const h=u-1;for(let r=0;r<e;r++)d.push((r+1)%e,r,h);return{vertex:c,normal:l,indices:new Uint16Array(d)}}(),z=function(){const{seg_cirle:e,seg_edge:r,radius:n,edge_count:t,radius_inner:o,radius_edge:i}=v,a=Math.PI*t/r,u=-i*Math.cos(a);return f(e,o+i*Math.sin(a),u)}(),G=f(64,1,0),Y=f(64,.94,1e-4);async function O(e){const r=t(),n=await ve(e.texture);return{view:r,parts:[{programInfo:R,geomertry:G,uBaseColor:{func:"uniform3fv",v:e.baseColor}},{programInfo:S,geomertry:Y,texture:n,uInverseRadius:{func:"uniform1f",v:1/Y.vertex[0]}}]}}async function q(e){const r=t(),o=await ve(e.texture);return{view:r,parts:[{programInfo:n,geomertry:X,uBaseColor:{func:"uniform3fv",v:e.baseColor}},{programInfo:a,geomertry:z,texture:o,uInverseRadius:{func:"uniform1f",v:1/z.vertex[0]}}]}}async function H(e){const r=t(),n=await fe(e.cubeTexture),o=await ve(e.texture);return{view:r,parts:[{programInfo:U,geomertry:X,texture:de(e.baseColor),cubeTexture:n,uInverseRadius:{func:"uniform1f",v:1}},{programInfo:U,geomertry:z,texture:o,cubeTexture:n,uInverseRadius:{func:"uniform1f",v:1/z.vertex[0]}}]}}async function W(e){const r=t(),n=await fe(e.cubeTexture),o=await ve(e.texture),i=await me(e.normalTexture);return{view:r,parts:[{programInfo:U,geomertry:X,texture:de(e.baseColor),cubeTexture:n,uInverseRadius:{func:"uniform1f",v:1}},{programInfo:L,geomertry:z,texture:o,texture2:i,cubeTexture:n,uInverseRadius:{func:"uniform1f",v:1/z.vertex[0]}}]}}l(ee,X),l(ee,z),l(ee,G),l(ee,Y),ae=ee.createTexture(),ee.bindTexture(ee.TEXTURE_2D,ae),ie=async function(e){const r={basic:q,min:O,basic_reflect:H,basic_reflect_normal:W}[e.type],n=await r(e);return n.name=e.name,n.desc=e.desc,n},function(e,r){!function(e,r){let n=0,t=null,o=!1,i=!1;function a(){const e=performance.now();i&&(r(t,e-n),i=!1)}e.addEventListener("mousedown",(function(e){o||(n=performance.now(),i=!0)})),e.addEventListener("touchstart",(function(r){o=!0,t=b(e,r.touches[0]),n=performance.now(),i=!0})),e.addEventListener("mouseup",(function(r){o||(t=b(e,r),a())})),e.addEventListener("touchend",(function(e){a(),o=!1})),e.addEventListener("mouseout",(function(e){i=!1})),e.addEventListener("touchcancel",(function(e){i=!1,o=!1})),e.addEventListener("focusout",(function(e){i=!1,o=!1}))}(e,j);const n=45*Math.PI/180,t=r.canvas.clientWidth/r.canvas.clientHeight;o(I,n,t,N,A)}(k,ee),$.className="fine-medal_idle",$.querySelector("button").onclick=()=>function(e){e.className="fine-medal_show_trans",w.className="",F=!1,setTimeout((()=>{w=null,e.className="fine-medal_idle"}),500)}($)}async function ce(e,r){$.className="fine-medal_init",await ge(),J=$.getBoundingClientRect();const n=document.querySelector(e);n.innerHTML="";const t=await Promise.all(r.map((async e=>{let r=oe[e];return r||(oe[e]=await ie(re.medals[e]),r=oe[e],r.id=e),r})));for(const e of t){let r=e.preview;r||(X(ee,e,!1,0),await ge(),e.preview=await he(k),r=e.preview);const t=document.createElement("div");t.setAttribute("data-id",e.id),t.title=e.name;let o=new Image;o.src=r,t.appendChild(o),t.addEventListener("click",(()=>{C(t,$,re.dialog_selector,J,K,(()=>{X(ee,e,!0,2),Z.innerHTML=e.name,Q.innerHTML=e.desc}))})),n.appendChild(t)}$.className="fine-medal_idle"}const le={};async function se(e){return le[e]||new Promise(((r,n)=>{let t=new Image;t.onload=()=>{le[e]=t,r(t)},t.onerror=n,t.src=e}))}async function me(e){const r=ne[e];if(r)return r;const n=await se(re.texturePath+e+re.textureExt),t=ee.createTexture();ee.bindTexture(ee.TEXTURE_2D,t);const o=ee.RGB,i=ee.RGB,a=ee.UNSIGNED_BYTE;return ee.texImage2D(ee.TEXTURE_2D,0,o,i,a,n),ee.generateMipmap(ee.TEXTURE_2D),ne[e]=t,t}async function fe(e){const r=[{target:ee.TEXTURE_CUBE_MAP_POSITIVE_X,n:"-px"},{target:ee.TEXTURE_CUBE_MAP_NEGATIVE_X,n:"-nx"},{target:ee.TEXTURE_CUBE_MAP_POSITIVE_Y,n:"-py"},{target:ee.TEXTURE_CUBE_MAP_NEGATIVE_Y,n:"-ny"},{target:ee.TEXTURE_CUBE_MAP_POSITIVE_Z,n:"-pz"},{target:ee.TEXTURE_CUBE_MAP_NEGATIVE_Z,n:"-nz"}],n=te[e];if(n)return n;const t=await Promise.all(r.map((async r=>{const n=await se(re.texturePath+e+r.n+re.textureExt);return{target:r.target,img:n}}))),o=ee.createTexture();ee.bindTexture(ee.TEXTURE_CUBE_MAP,o);for(const e of t){const{target:r,img:n}=e,t=0,o=ee.RGB,i=ee.RGB,a=ee.UNSIGNED_BYTE;ee.texImage2D(r,t,o,i,a,n)}return ee.generateMipmap(ee.TEXTURE_CUBE_MAP),ee.texParameteri(ee.TEXTURE_CUBE_MAP,ee.TEXTURE_MIN_FILTER,ee.LINEAR_MIPMAP_LINEAR),te[e]=o,o}function ve(e){return Array.isArray(e)?de(e):"string"==typeof e?me(e):void 0}function de(e){ee.bindTexture(ee.TEXTURE_2D,ae);const r=ee.RGB,n=ee.RGB,t=ee.UNSIGNED_BYTE,o=new Uint8Array(e.map((e=>255*e)));return ee.texImage2D(ee.TEXTURE_2D,0,r,1,1,0,n,t,o),ae}async function he(e){return new Promise(((r,n)=>{e.toBlob((e=>{if(e){const n=URL.createObjectURL(e);r(n)}else n(new Error("Canvas toBlob failed."))}))}))}async function ge(){return new Promise((e=>{requestAnimationFrame(e)}))}function xe(e){return z(e)}fineMedal=r})();