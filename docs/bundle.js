(()=>{"use strict";var r="undefined"!=typeof Float32Array?Float32Array:Array;function e(){var e=new r(16);return r!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function o(r,e,o){var n,t,a,i,c,s,u,l,f,m,v,g,h=o[0],d=o[1],p=o[2];return e===r?(r[12]=e[0]*h+e[4]*d+e[8]*p+e[12],r[13]=e[1]*h+e[5]*d+e[9]*p+e[13],r[14]=e[2]*h+e[6]*d+e[10]*p+e[14],r[15]=e[3]*h+e[7]*d+e[11]*p+e[15]):(n=e[0],t=e[1],a=e[2],i=e[3],c=e[4],s=e[5],u=e[6],l=e[7],f=e[8],m=e[9],v=e[10],g=e[11],r[0]=n,r[1]=t,r[2]=a,r[3]=i,r[4]=c,r[5]=s,r[6]=u,r[7]=l,r[8]=f,r[9]=m,r[10]=v,r[11]=g,r[12]=n*h+c*d+f*p+e[12],r[13]=t*h+s*d+m*p+e[13],r[14]=a*h+u*d+v*p+e[14],r[15]=i*h+l*d+g*p+e[15]),r}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var r=0,e=arguments.length;e--;)r+=arguments[e]*arguments[e];return Math.sqrt(r)});function n(r,e){var o=e[0],n=e[1],t=e[2],a=e[3],i=e[4],c=e[5],s=e[6],u=e[7],l=e[8],f=e[9],m=e[10],v=e[11],g=e[12],h=e[13],d=e[14],p=e[15],x=o*c-n*i,M=o*s-t*i,_=o*u-a*i,A=n*s-t*c,E=n*u-a*c,T=t*u-a*s,R=l*h-f*g,P=l*d-m*g,y=l*p-v*g,F=f*d-m*h,b=f*p-v*h,B=m*p-v*d,C=x*B-M*b+_*F+A*y-E*P+T*R;return C?(C=1/C,r[0]=(c*B-s*b+u*F)*C,r[1]=(s*y-i*B-u*P)*C,r[2]=(i*b-c*y+u*R)*C,r[3]=(t*b-n*B-a*F)*C,r[4]=(o*B-t*y+a*P)*C,r[5]=(n*y-o*b-a*R)*C,r[6]=(h*T-d*E+p*A)*C,r[7]=(d*_-g*T-p*M)*C,r[8]=(g*E-h*_+p*x)*C,r):null}function t(r,e,o){const n=r.createShader(e);return r.shaderSource(n,o),r.compileShader(n),r.getShaderParameter(n,r.COMPILE_STATUS)?n:(alert("An error occurred compiling the shaders: "+r.getShaderInfoLog(n)),r.deleteShader(n),null)}function a(r,e,o){const n=t(r,r.VERTEX_SHADER,e),a=t(r,r.FRAGMENT_SHADER,o),i=r.createProgram();return r.attachShader(i,n),r.attachShader(i,a),r.linkProgram(i),r.getProgramParameter(i,r.LINK_STATUS)?i:(alert("Unable to initialize the shader program: "+r.getProgramInfoLog(i)),null)}function i(r,e,o,n,t=""){o=o.split(" "),n=n.split(" "),t=t.split(" ");const a={program:e,attribLocations:{},uniformLocations:{},uniformLocations_ext:{}};return o.forEach((o=>a.attribLocations[o]=r.getAttribLocation(e,o))),n.forEach((o=>a.uniformLocations[o]=r.getUniformLocation(e,o))),t.forEach((o=>a.uniformLocations_ext[o]=r.getUniformLocation(e,o))),a}function c(r,e){e.vertexBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,e.vertexBuffer),r.bufferData(r.ARRAY_BUFFER,e.vertex,r.STATIC_DRAW),e.normalBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,e.normalBuffer),r.bufferData(r.ARRAY_BUFFER,e.normal,r.STATIC_DRAW),e.indexBuffer=r.createBuffer(),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e.indexBuffer),r.bufferData(r.ELEMENT_ARRAY_BUFFER,e.indices,r.STATIC_DRAW)}function s(r){const e=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);return[r[0]/e,r[1]/e,r[2]/e]}function u(r,e,o=0){const n=[];for(let t=0;t<r;t++){const a=2*Math.PI*t/r,i=e*Math.cos(a),c=e*Math.sin(a);n.push([i,c,o])}return n}const l={seg_cirle:64,seg_edge:32,radius:1,edge_count:Math.floor(128/3),radius_inner:.9,radius_edge:1-.9};const f=[-0,0,-6],m=["test"];window.addEventListener("load",(async function(){const t=function(r){const e=r.getContext("webgl")||r.getContext("experimental-webgl");return e?(e.clearColor(0,0,0,0),e.clearDepth(1),e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),e.depthFunc(e.LEQUAL),e):(alert("Unable to initialize WebGL. Your browser may not support it."),null)}(document.querySelector("canvas"));if(!t)return;const v=m.map((async r=>({img:await async function(r){return new Promise(((e,o)=>{let n=new Image;n.onload=()=>e(n),n.onerror=o,n.src=r}))}(r+".jpg"),name:r}))),g=await Promise.all(v),h={};g.forEach((r=>{const e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);const o=t.RGB,n=t.RGB,a=t.UNSIGNED_BYTE;t.texImage2D(t.TEXTURE_2D,0,o,n,a,r.img),t.generateMipmap(t.TEXTURE_2D),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),h[r.name]=e}));const d=a(t,"attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp vec3 uBaseColor;\nvarying highp vec3 vColor;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    highp vec3 viewDir = vec3(0, 0, -1);\n    highp float amb = max(-dot(vTransformedNormal, viewDir), 0.0);\n    vColor = uBaseColor * (0.5 + 0.5 * amb);\n}","varying highp vec3 vColor;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nvoid main(void) {\n    highp vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    highp float shininess = 32.0;\n          \n    //gl_FragColor = texture2D(uSampler, vTextureCoord)\n    highp vec3 lightDir = normalize(vPosition - vec3(0, 0, 2));\n    highp vec3 viewDir = normalize(vec3(0.0, -0.0, -1));\n    highp vec3 reflectDir = reflect(-lightDir, vTransformedNormal);\n    highp float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    specularColor = specular * specularColor;\n\n    gl_FragColor = vec4(vColor + specularColor, 1.0);\n    //gl_FragColor = vec4(vColor, 1.0); //for debug\n   \n}"),p=i(t,d,"aVertexPosition aVertexNormal","uModelViewMatrix uProjectionMatrix uNormalMatrix","uBaseColor"),x=a(t,"attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform highp float uInverseRadius;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec2 vTextureCoord;\nvarying highp vec3 vPosition;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n    vPosition = (uModelViewMatrix * vec4(aVertexPosition, 1.0)).xyz;\n    vTransformedNormal = normalize(uNormalMatrix * aVertexNormal);\n    float x = aVertexPosition.x * uInverseRadius;\n    float y = aVertexPosition.y * uInverseRadius;\n    vTextureCoord = vec2(\n        x * 0.5 + 0.5,\n        y * 0.5 + 0.5\n    );\n}","varying highp vec2 vTextureCoord;\nvarying highp vec3 vTransformedNormal;\nvarying highp vec3 vPosition;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    highp vec4 baseColor = texture2D(uSampler, vTextureCoord);\n\n    highp vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    highp float shininess = 32.0;\n          \n    highp vec3 lightDir = normalize(vPosition - vec3(0, 0, 2));\n    highp vec3 viewDir = normalize(vec3(0.0, -0.0, -1));\n    highp vec3 reflectDir = reflect(-lightDir, vTransformedNormal);\n    highp float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    specularColor = specular * specularColor;\n    gl_FragColor = baseColor + vec4(specularColor, 1.0);\n\n}\n"),M=i(t,x,"aVertexPosition aVertexNormal","uSampler uModelViewMatrix uProjectionMatrix uNormalMatrix","uInverseRadius"),_=function(){const{seg_cirle:r,seg_edge:e,radius:o,edge_count:n,radius_inner:t,radius_edge:a}=l,i=[];for(let o=0;o<=n;o++){const n=Math.PI*o/e,c=-a*Math.cos(n),s=a*Math.sin(n);i.push(u(r,t+s,c))}const c=i.length*r+1,f=new Float32Array(3*c),m=new Float32Array(3*c);let v=0;i.forEach((r=>{r.forEach((r=>{f.set(r,v);const e=function(r,e){const o=r[0],n=r[1],t=r[2],a=s([o,n,0]).map((r=>r*e));return s([o-a[0],n-a[1],t-a[2]])}(r,t);m.set(e,v),v+=3}))})),f.set([0,0,-a],v),m.set([0,0,-1],v);const g=[];for(let e=0;e<i.length-1;e++){const o=e*r;for(let e=0;e<r;e++)g.push(o+e,o+(e+1)%r,o+e+r),g.push(o+(e+1)%r,o+(e+1)%r+r,o+e+r)}const h=c-1;for(let e=0;e<r;e++)g.push((e+1)%r,e,h);return{vertex:f,normal:m,indices:new Uint16Array(g)}}(),A=function(){const{seg_cirle:r,seg_edge:e,radius:o,edge_count:n,radius_inner:t,radius_edge:a}=l,i=Math.PI*n/e,c=-a*Math.cos(i),s=u(r,t+a*Math.sin(i),c),f=r+1,m=new Float32Array(3*f),v=new Float32Array(3*f);let g=0,h=[0,0,1];s.forEach((r=>{m.set(r,g),v.set(h,g),g+=3})),m.set([0,0,c],g),v.set(h,g);const d=[],p=f-1;for(let e=0;e<r;e++)d.push(e,(e+1)%r,p);return{vertex:m,normal:v,indices:new Uint16Array(d)}}();c(t,_),c(t,A);const E=[function(){const r=e();return o(r,r,f),{view:r,parts:[{programInfo:p,geomertry:_,uBaseColor:{func:"uniform3fv",v:[.3,.7,0]}},{programInfo:M,geomertry:A,texture:h.test,uInverseRadius:{func:"uniform1f",v:1/A.vertex[0]}}]}}()];console.log(E);const T=e(),R=45*Math.PI/180,P=t.canvas.clientWidth/t.canvas.clientHeight;!function(r,e,o,n,t){var a,i=1/Math.tan(e/2);r[0]=i/o,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=i,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,null!=t&&t!==1/0?(a=1/(n-t),r[10]=(t+n)*a,r[14]=2*t*n*a):(r[10]=-1,r[14]=-2*n)}(T,R,P,.1,100);let y=0,F=0;requestAnimationFrame((function a(i){const c=(i*=.001)-F;F=i,y+=.9*c;const s=e();var u,l,m,v,g,h,d,p,x,M,_,A,R;o(s,s,f),u=s,l=s,m=y,v=Math.sin(m),g=Math.cos(m),h=l[0],d=l[1],p=l[2],x=l[3],M=l[8],_=l[9],A=l[10],R=l[11],l!==u&&(u[4]=l[4],u[5]=l[5],u[6]=l[6],u[7]=l[7],u[12]=l[12],u[13]=l[13],u[14]=l[14],u[15]=l[15]),u[0]=h*g-M*v,u[1]=d*g-_*v,u[2]=p*g-A*v,u[3]=x*g-R*v,u[8]=h*v+M*g,u[9]=d*v+_*g,u[10]=p*v+A*g,u[11]=x*v+R*g;for(const r of E)r.view=s;!function(e,o,t,a){e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);for(const a of t)for(const t of a.parts){e.useProgram(t.programInfo.program),e.bindBuffer(e.ARRAY_BUFFER,t.geomertry.vertexBuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.geomertry.indexBuffer),e.enableVertexAttribArray(t.programInfo.attribLocations.aVertexPosition),e.vertexAttribPointer(t.programInfo.attribLocations.aVertexPosition,3,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,t.geomertry.normalBuffer),e.enableVertexAttribArray(t.programInfo.attribLocations.aVertexNormal),e.vertexAttribPointer(t.programInfo.attribLocations.aVertexNormal,3,e.FLOAT,!1,0,0),e.uniformMatrix4fv(t.programInfo.uniformLocations.uProjectionMatrix,!1,o),e.uniformMatrix4fv(t.programInfo.uniformLocations.uModelViewMatrix,!1,a.view);const c=(i=void 0,i=new r(9),r!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[5]=0,i[6]=0,i[7]=0),i[0]=1,i[4]=1,i[8]=1,i);n(c,a.view),e.uniformMatrix3fv(t.programInfo.uniformLocations.uNormalMatrix,!1,c);for(const r in t.programInfo.uniformLocations_ext){const o=t.programInfo.uniformLocations_ext[r],n=t[r];e[n.func](o,n.v)}void 0!==t.programInfo.uniformLocations.uSampler&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t.texture),e.uniform1i(t.programInfo.uniformLocations.uSampler,0));const s=t.geomertry.indices.length,u=0;e.drawElements(e.TRIANGLES,s,e.UNSIGNED_SHORT,u)}var i}(t,T,E),requestAnimationFrame(a)}))}))})();